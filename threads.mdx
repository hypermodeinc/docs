---
title: "Threads: your AI agent workbench"
sidebarTitle: "Threads"
description:
  "Build, train, and iterate on AI agents through natural conversation—then
  deploy to production-ready code"
---

**Threads is where ideas become agents.** it's a conversational interface that
lets you build, train, and refine AI agents through natural language—no coding
required. When you're ready, deploy your agent as production-ready code.

Unlike traditional chat interfaces that forget everything when you close the
tab, Threads creates **persistent, purpose-built agents** that remember their
training and can be deployed as real software.

![Agents Intro](/images/threads/intro-workflow.png)

## Why threads matters

Most AI agent development follows a painful pattern:

1. **Business expert** describes what they need
2. **Developer** interprets and codes a solution
3. **Back-and-forth** to get it right
4. **Weeks later**, maybe you have what you wanted

**Threads eliminates this translation loss.** Domain experts work directly with
agents, training them through conversation, seeing immediate results, and
iterating in real-time. When ready, **eject to code** exports your trained agent
as a complete Modus app.

```text
Traditional: Idea → Requirements → Code → Deploy → Test → Repeat
Threads:     Idea → Conversation → Working Agent → Eject to Code
```

## Core concepts

### Agents, not chats

Every conversation in Threads is building toward a **reusable agent**. Unlike
ChatGPT where conversations disappear, your Threads interactions create agents
that can:

- Remember their training across sessions
- Be deployed as production code through Hypermode's infrastructure
- Work with your specific tools and data through Connections
- Handle complex, multi-step workflows

### Tools, not just text

Agents in Threads don't just chat—they **act**. Through Connections, your agents
can:

- Access your Slack channels and manage team communications
- Create Linear issues when bugs are found
- Query GitHub repositories and analyze pull requests
- Check your Vercel deployments and build logs
- Search the web for up-to-date information
- Integrate with custom tools through Model Context Protocol (MCP) servers

### Natural language to deployable code

Everything you build in Threads can be **exported as real software**:

- Your agent's personality and instructions
- The tools it has access to
- Its conversation patterns and responses
- Complete Modus apps through **eject to code**

## Connections

**Hypermode Agents get access to a vast ecosystem of tools and integrations by
default.** Through Connections, your agents can seamlessly integrate with
popular services and your own custom APIs.

![Agent Connections Ecosystem](/images/threads/agent-ecosystem.png)

### Built-in integrations

Hypermode provides native, production-ready connections to essential business
tools:

- **GitHub** for repository management and pull request analysis
- **Linear** for project management and issue tracking
- **Slack** for team communication and notifications
- **Vercel** for deployment monitoring and build log analysis
- **Notion** for documentation and knowledge management
- **Exa** for enhanced web search capabilities

### Model context protocol support

Hypermode fully supports the **Model Context Protocol**, an open standard for
secure, structured tool integration. Your agents can connect to any
MCP-compatible service and integrate with custom MCP servers you build for
internal tools.

### Pipedream's 2000+ integrations

Through **Pipedream Connect**, your agents gain instant access to over **2000
pre-built integrations** across the software ecosystem. This includes:

- Customer relationship management platforms like Salesforce and HubSpot
- Marketing tools like Mailchimp and Google Analytics
- Communication platforms such as Discord and Microsoft Teams
- E-commerce solutions like Shopify and Stripe
- Cloud services and productivity suites

### Security and permissions

All connections are secured by default with:

- **Scoped access** so agents only get tools relevant to their role
- **Encrypted credentials** for all API keys and tokens
- **Audit logging** to track every tool interaction
- **Team controls** for admins to manage connection access

## Getting started: your first agent

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/images/threads/agent-card.png"
    alt="Your First Agent"
    style={{
      width: "60%",
      maxWidth: "60%",
      height: "auto",
      display: "block",
      margin: "0 auto",
    }}
  />
</div>

Let's build a **Code Review Agent** that helps catch bugs and suggest
improvements. This example shows how Threads transforms a simple idea into a
working agent.

### Step 1: start with intent

![Your First Thread](/images/threads/minimal-chat.png)

```text
You: "I need an agent that reviews pull requests, checks for security issues,
     and suggests better variable names"

Hypermode Concierge: "I'll help you build a Code Review Agent. Let me set up the basic
                      structure and tools..."
```

The Hypermode Concierge (Hypermode's agent-building agent) scaffolds your new
agent with:

- A focused system prompt
- Access to GitHub tools through Connections
- Code analysis capabilities
- Customized instructions for your workflow

### Step 2: train through conversation

Through iterative dialogue, you refine your agent's behavior in real-time—each
exchange teaches it to better understand your specific requirements and workflow
preferences.

![Train through conversation](/images/threads/training-chat.png)

```text
You: "Here's a PR with a potential SQL injection vulnerability"
[Pastes code snippet]

Agent: *Analyzes code using GitHub tools*
"I found a SQL injection risk on line 23. The user input isn't sanitized
before being passed to the query. I'd recommend using parameterized queries."

You: "Good catch! But also check variable naming conventions"

Agent: *Updates behavior based on your feedback*
"You're right. I also notice variables like 'data1' and 'temp_thing'
should be more descriptive. I'll include naming suggestions in future reviews."

You: "Perfect. Now I want to deploy this agent"
```

### Step 3: deploy to production

When your agent works exactly how you want:

![Deploy agent through conversation](/images/threads/deploy-chat.png)

```text
You: "I want to deploy this agent to handle our GitHub PRs automatically"

Threads: *Agent is now available for deployment through Hypermode*
- Agent configuration and prompts saved
- Tool integrations and permissions configured
- Ready for deployment
- Accessible through Hypermode's infrastructure
```

Your conversation just became a **deployable agent**.

### Step 4: iterate and enhance

Your agent is working, but now you want to streamline your team's workflow.
Through continued conversation, you can enhance your agent's capabilities in
real-time.

![Iterate and enhance](/images/threads/training-chat-2.png)

```text
You: "When you find issues in PRs, can you create Linear tickets automatically?
     That would save us a lot of manual work."

Agent: "Absolutely! I can integrate with Linear to create tickets for issues I find.
        I'll need access to your Linear workspace. What priority should I set for
        security issues vs. code quality issues?"

You: "Security issues should be High priority, code quality Medium.
     Tag them with 'code-review-bot' so we know the source."

Agent: "Perfect! I'm now connecting to Linear and updating my workflow:
        • Security vulnerabilities → High priority Linear tickets
        • Code quality issues → Medium priority tickets
        • All tickets tagged with 'code-review-bot'
        Ready to test! Try submitting a PR with issues."
```

Now your agent has evolved into a **fully automated workflow** that not only
reviews code but takes action on what it finds:

![Enhanced workflow](/images/threads/workflow-diagram.png)

**Your enhanced agent now**:

- Analyzes every new pull request automatically
- Detects security vulnerabilities and code quality issues
- Creates prioritized Linear tickets with appropriate tags
- Comments on PRs with detailed feedback and ticket links
- Maintains context about your team's priorities and conventions

**What changed**: through a simple 3-message conversation, your agent learned to
integrate with Linear, understand your priority system, and automate ticket
creation. No configuration files, no API documentation—just natural language
instruction.

**The result**: your team's code review process is now fully automated, from
detection to ticket creation, saving hours of manual work while ensuring nothing
falls through the cracks.

## Eject to code: from conversation to deployable software

Your Code Review Agent works perfectly in Threads—automatically hosted and
maintained. But if you want to hand it off to your development team or integrate
it into larger systems, **eject to code** lets you export everything you built
through natural language as a complete Modus app.

### From threads to Modus code

Remember your Code Review Agent that analyzes pull requests and creates Linear
tickets? Here's what that conversation becomes when exported:

```go
// Your Threads conversation becomes this structured agent
type CodeReviewAgent struct {
    agents.AgentBase

    // Persistent memory - remembers your training
    ReviewHistory     []CodeReview
    TeamPreferences   TeamSettings
    SecurityRules     []SecurityCheck
    NamingConventions []NamingRule
}

// Your natural language instructions become system prompts
func (a *CodeReviewAgent) analyzePullRequest(prData string) (*string, error) {
    systemPrompt := buildPromptFromThreadsTraining(
        a.TeamPreferences,    // "Security issues are high priority"
        a.NamingConventions,  // "Avoid names like 'data1', 'temp_thing'"
        a.ReviewHistory,      // Learns from previous reviews
    )

    // AI analysis with your trained context
    analysis := model.Invoke(systemPrompt, prData)

    // Tool integrations you configured in Connections
    for issue := range extractIssues(analysis) {
        if issue.Type == "security" {
            linearAPI.CreateTicket(issue, priority="High", tag="code-review-bot")
        }
    }

    // State persists across sessions automatically
    a.ReviewHistory = append(a.ReviewHistory, newReview)

    return formatResponse(analysis, ticketsCreated)
}

// GraphQL API generated automatically
func ReviewPullRequest(agentId string, prData string) (string, error) {
    return agents.SendMessage(agentId, "review_pull_request", prData)
}
```

### The power of eject to code

#### **From conversation to real software**

**What you built in Threads:**

- "Check for security issues and suggest better variable names"
- "Create Linear tickets with high priority for security, medium for quality"
- "Tag everything with 'code-review-bot'"

**What gets exported:**

- Complete Modus agent with persistent memory
- Your exact training becomes structured system prompts
- Tool integrations (GitHub, Linear) configured and functional
- GraphQL API ready for deployment

#### **Built on open source Modus**

Your exported agent runs on **Modus**, Hypermode's open source agent runtime:

```bash
# Your agent becomes a standard Modus app
git clone your-exported-agent
cd code-review-agent
modus dev      # Local development
modus deploy   # Production deployment
```

**Key advantages:**

- **No vendor lock-in**: Your code runs anywhere Modus runs
- **Open source ecosystem**: Extend with community tools and integrations
- **Standard DevOps**: CI/CD, testing, monitoring work normally
- **Full transparency**: Complete visibility into agent behavior

#### **Enterprise-grade architecture**

The exported code isn't a prototype—it's enterprise-grade software:

- **Persistent State**: Agent memory survives restarts and failures
- **Concurrency**: Handle thousands of simultaneous operations
- **Sandboxing**: Each agent instance runs in isolation
- **Observability**: Built-in logging, tracing, and debugging
- **Security**: Tool access scoped to agent roles

#### **Developer-friendly handoff**

Platform teams get real software they can audit and extend while preserving all
the natural language training from Threads.

### Ready to build sophisticated agents?

**This is just the beginning.** The pseudo-code shown here demonstrates the
concept, but Modus provides a complete framework for building sophisticated,
stateful agents that scale.

**Your agent works perfectly in Threads.** For many use cases, keeping your
agent hosted automatically in Threads is ideal—it handles deployment, scaling,
and maintenance for you.

**Ready for more control?** If you're looking to hand off to other engineers,
integrate with existing systems, or build coordinated multi-agent workflows, you
can eject to code and get a complete Modus app that your development team can
own, extend, and deploy anywhere.

**Learn more about building agents with Modus:** For complete documentation on
agent development, tool integration, and deployment, visit our
[Developer Documentation](/developers).

**Your Threads conversation was just the design phase.** With Modus, you can
build agents that become as reliable and scalable as any microservice in your
infrastructure.

## Real-world examples

### Sales pipeline agent

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/images/threads/sales-agent-card.png"
    alt="Sales Pipeline Agent"
    style={{
      width: "60%",
      maxWidth: "60%",
      height: "auto",
      display: "block",
      margin: "0 auto",
    }}
  />
</div>

**What it does**: analyzes your sales data and manages pipeline activities when
you ask, integrating Stripe, HubSpot, and Slack.

```text
Training conversation:

You: "Check our HubSpot pipeline and tell me which deals need follow-up this week"

Agent: "I'll analyze your pipeline and identify deals requiring attention.
        What criteria should I use to prioritize follow-ups?"

You: "Deals over $10k that haven't been contacted in 5+ days, and any deals in 'proposal sent' stage for more than a week"

Agent: "Got it. I'll check those criteria and provide a prioritized list.
        Should I also draft follow-up messages for the sales team?"

You: "Yes, and check our Stripe data to see if any recent payments need to be updated in HubSpot"

Agent: "I'll analyze both systems, suggest follow-ups, and flag any data sync issues between Stripe and HubSpot."

You: "This will save me hours each week. Can I deploy this sales agent for my team?"

Agent: "Absolutely! Would you like to deploy this sales pipeline agent so your team can use it for deal analysis?"

You: "Yes, deploy it now"

Agent: *Agent is now deployed and ready for your sales team to use*
```

**Current capabilities**:

- **Pipeline analysis** for deal status and follow-up recommendations
- **HubSpot deal review** with updates and notifications
- **Stripe payment reconciliation** to check for sync issues
- **Slack reporting** to share insights with your sales team
- **Deal prioritization** based on your criteria for pipeline review
- **Follow-up suggestions** with draft messages for outreach

**Business impact**: a marketing agency reduced pipeline review time from 2
hours to 15 minutes and improved follow-up consistency with their agent's
pipeline analysis.

### Customer support agent

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/images/threads/customer-support-agent-card.png"
    alt="Sales Pipeline Agent"
    style={{
      width: "60%",
      maxWidth: "60%",
      height: "auto",
      display: "block",
      margin: "0 auto",
    }}
  />
</div>

**What it does**: analyzes support tickets and customer inquiries when you ask,
providing insights and suggested responses across email and support platforms.

```text
Training conversation:

You: "Check our support emails from today and categorize the urgent issues"

Agent: "I'll review your support inbox and identify urgent items by keywords and sender history.
        What makes an issue urgent for your team?"

You: "Billing problems, system outages, and angry customers. Group them by type and draft responses"

Agent: "I'll categorize today's emails by urgency and type, then suggest appropriate responses for each category."

You: "Great, and check if any tickets in our system need escalation to engineering"

Agent: "I'll review open tickets, identify technical issues that need engineering attention, and draft escalation summaries."

You: "This is going to streamline our entire support process. Can I deploy this agent?"

Agent: "Absolutely! Would you like to deploy this customer support agent so your team can use it for ticket analysis?"

You: "Yes, deploy it now"

Agent: *Agent is now deployed and ready for your support team to use*
```

**Current capabilities**:

- **email analysis** for inbox review and categorization
- **Ticket prioritization** based on your criteria for support queue analysis
- **Response drafting** for common issues and customer communication
- **Escalation identification** for issues that need team attention
- **Customer sentiment analysis** to check satisfaction levels
- **Knowledge base suggestions** for relevant help articles

**Business impact**: a SaaS company reduced support triage time from 2 hours to
20 minutes with their agent's daily support request analysis and categorization.

### Marketing insights agent

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/images/threads/marketing-agent-card.png"
    alt="Sales Pipeline Agent"
    style={{
      width: "60%",
      maxWidth: "60%",
      height: "auto",
      display: "block",
      margin: "0 auto",
    }}
  />
</div>

**What it does**: analyzes marketing performance across channels when you ask,
providing campaign insights and optimization recommendations.

```text
Training conversation:

You: "Check how our email campaign performed last week and compare it to our social media posts"

Agent: "I'll pull data from Mailchimp and your social platforms to compare performance.
        What metrics matter most for your campaigns?"

You: "Email open rates, click-through rates, and social engagement. Also check which content drove the most website traffic"

Agent: "I'll analyze those metrics and identify your top-performing content across channels."

You: "Perfect, and give me recommendations for next week's campaigns based on what worked best"

Agent: "I'll review the data patterns and suggest content types, timing, and messaging for your upcoming campaigns."

You: "This is exactly what I need for my weekly marketing reviews. Can I deploy this agent?"

Agent: "Absolutely! Would you like to deploy this marketing insights agent so your team can access it?"

You: "Yes, deploy it now"

Agent: *Agent is now deployed and ready for your team to use for marketing analysis*
```

**Current capabilities**:

- **Campaign analysis** for performance reviews across email and social
  platforms
- **Cross-channel comparison** to see how different platforms are performing
- **Content performance insights** to understand what resonates with your
  audience
- **Optimization recommendations** based on data analysis for campaign
  improvements
- **Audience segmentation analysis** to understand engagement patterns
- **Return on investment calculations** to measure campaign effectiveness

**Business impact**: an e-commerce brand improved campaign return on investment
by 60% and reduced campaign analysis time from 4 hours to 30 minutes with their
agent's weekly performance reviews.

## Advanced patterns

### Agent specialization

Agents can be built for specific domains with tailored tool access:

```text
GitHub Agent → Specialized for code review and repository management
     ↓
Slack Agent → Focused on team communication and coordination
     ↓
Vercel Agent → Optimized for deployment analysis and infrastructure
```

Each agent excels in its domain while maintaining consistent behavior patterns.

### Task automation

Turn any conversation into automated workflows:

```text
You: "Create a task that analyzes our weekly GitHub activity"

Threads: *Generates structured task definition*
- Captures conversation context
- Defines repeatable workflow
- Maintains agent configuration
```

### Context persistence

Agents remember training across sessions:

```text
Agent: "Based on our previous conversations, I remember you prefer detailed
        code reviews with security focus. Should I continue with that approach?"

You: "Yes, but also add performance considerations"

Agent: "I'll update my review criteria to include performance analysis
        alongside security and code quality."
```

## Model flexibility

Threads works with **multiple models** through Hypermode's Model Router:

- **Generative Pre-trained Transformer 4.1**: Latest OpenAI model for complex
  reasoning and code analysis
- **Claude 4**: Anthropic's advanced model for writing and analysis tasks
- **Gemini**: Google's model for multi-modal tasks and data processing
- **O1/O3**: OpenAI's reasoning models for complex problem-solving
- **Open source models**: Llama, Mistral, and other community models

Switch models to optimize for different tasks:

```text
You: "Use Claude for the writing tasks and GPT-4.1 for code analysis"

Agent: *Adapts model usage based on task type*
"I'm now using Claude for documentation and GPT-4.1 for technical analysis.
The combination provides better results for both areas."
```

## Security and governance

### Tool access control

Agents only get the tools they need:

- **GitHub Agent**: Repository access only (no deployment permissions)
- **Slack Agent**: Communication tools only (no code access)
- **Vercel Agent**: Deployment analysis only (no user data access)

### Team collaboration

- **Domain experts** build and train agents through conversation
- **Platform teams** manage deployment and infrastructure
- **Security teams** audit tool permissions and data access

### Full observability

Every agent action is traceable:

- Tool calls and responses logged
- Message history preserved
- Agent behavior patterns tracked
- Performance metrics collected

## Best practices

### Start specific

```text
❌ "Build me a general assistant"
✅ "Build an agent that analyzes our GitHub PRs and creates Linear issues for bugs"
```

### Train iteratively

```text
❌ "Here's a 500-line requirements document"
✅ "Let's start with basic PR reviews and add complexity through conversation"
```

### Deploy early

```text
❌ "Perfect every detail before deploying"
✅ "Deploy working versions and iterate based on real usage"
```

### Document context

```text
❌ "Figure out what I mean"
✅ "When I say 'urgent', treat it as high priority and notify the team lead"
```

## Get started today

Ready to build your first agent? Here's how:

1. **[Sign up for Hypermode](https://hypermode.com)** and access Threads
2. **Start a conversation** with the Hypermode Concierge about what you want to
   build
3. **Train your agent** through natural language iteration
4. **Configure tool access** through Connections
5. **Deploy and monitor** with Hypermode's infrastructure

**Threads transforms how you think about AI**—from disposable conversations to
persistent, capable agents that integrate seamlessly with your existing tools
and workflows.

---

_Ready to turn your ideas into agents?
[Start building in Threads →](https://hypermode.com/threads)_

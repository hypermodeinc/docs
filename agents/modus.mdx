---
title: "Ejecting to code: Modus"
description:
  "Export your Threads conversations as production-ready Modus applications with
  full control and transparency"
---

Hypermode's **"eject to code"** feature lets you take visually or
conversationally built agents and export them as production-grade, audit-able
source code. This means you can iterate rapidly using Hypermode's agent-building
tools—and when you're ready, seamlessly turn the agent into real code that can
be reviewed, modified, versioned, and run anywhere your team needs.

**Hypermode doesn't not trap your logic in a black box.** you can always eject
to code for transparency, extensibility, and control—making the platform safe
and useful for both business users and engineers.

![Eject to code](/images/threads/eject-to-code-diagram.png)

## From conversation to code

Remember your Code Review Agent that analyzes pull requests and creates Linear
tickets? Here's what that Threads conversation becomes when exported as a Modus
app.

Exported agents are powered by the **Modus framework**. Once ejected, they
become standard microservices or API endpoints, deployable on your
infrastructure—just like any other well-structured software component. You can
version-control the generated code, customize the logic, and wrap it within your
organization's CI/CD, observability, and security practices.

This export-to-code model **bridges the gap between no/low-code agent creation
and production software engineering**. It gives non-technical users the power of
rapid prototyping, while developers retain full trust and control for real-world
deployments.

### Your agent becomes structured code

```go
package main

import (
    "fmt"
    "strings"
    "time"
    "github.com/hypermodeinc/modus/sdk/go/pkg/agents"
    "github.com/hypermodeinc/modus/sdk/go/pkg/models"
    "github.com/hypermodeinc/modus/sdk/go/pkg/models/openai"
)

type CodeReviewAgent struct {
    agents.AgentBase

    // Persistent memory - remembers your training from Threads
    ReviewHistory     []CodeReview     `json:"review_history"`
    TeamPreferences   TeamSettings     `json:"team_preferences"`
    SecurityRules     []SecurityCheck  `json:"security_rules"`
    NamingConventions []NamingRule     `json:"naming_conventions"`
    LastActivity      time.Time        `json:"last_activity"`
}

type TeamSettings struct {
    SecurityPriority    string   `json:"security_priority"`    // "High"
    QualityPriority     string   `json:"quality_priority"`     // "Medium"
    RequiredTags        []string `json:"required_tags"`        // ["code-review-bot"]
    NotificationChannel string   `json:"notification_channel"`
}

func (a *CodeReviewAgent) Name() string {
    return "CodeReviewAgent"
}
```

### Your training becomes system prompts

```go
func (a *CodeReviewAgent) buildSystemPrompt() string {
    return fmt.Sprintf(`You are a code review agent trained through conversation.

Your team preferences:
- Security issues: %s priority
- Code quality issues: %s priority
- Always tag tickets with: %v
- Focus on variable naming conventions (avoid 'data1', 'temp_thing')

Based on %d previous reviews, you've learned to:
- Identify SQL injection vulnerabilities
- Suggest parameterized queries for database access
- Recommend descriptive variable names
- Create Linear tickets automatically for issues found

Maintain the conversational tone and detailed feedback style established in training.`,
        a.TeamPreferences.SecurityPriority,
        a.TeamPreferences.QualityPriority,
        a.TeamPreferences.RequiredTags,
        len(a.ReviewHistory))
}
```

### Your tool integrations become functions

```go
func (a *CodeReviewAgent) analyzePullRequest(prData string) (*string, error) {
    // AI analysis with your trained context
    model, err := models.GetModel[openai.ChatModel]("gpt-4")
    if err != nil {
        return nil, err
    }

    systemPrompt := a.buildSystemPrompt()

    input, err := model.CreateInput(
        openai.NewSystemMessage(systemPrompt),
        openai.NewUserMessage(fmt.Sprintf("Review this pull request:\n%s", prData)),
    )
    if err != nil {
        return nil, err
    }

    output, err := model.Invoke(input)
    if err != nil {
        return nil, err
    }

    analysis := output.Choices[0].Message.Content

    // Tool integrations you configured in Connections
    issues := a.extractIssues(analysis)
    var ticketsCreated []string

    for _, issue := range issues {
        if strings.Contains(strings.ToLower(issue.Type), "security") {
            ticket, err := a.createLinearTicket(issue, "High", a.TeamPreferences.RequiredTags)
            if err == nil {
                ticketsCreated = append(ticketsCreated, ticket)
            }
        } else {
            ticket, err := a.createLinearTicket(issue, "Medium", a.TeamPreferences.RequiredTags)
            if err == nil {
                ticketsCreated = append(ticketsCreated, ticket)
            }
        }
    }

    // State persists across sessions automatically
    a.ReviewHistory = append(a.ReviewHistory, CodeReview{
        PullRequest: prData,
        Analysis:    analysis,
        Issues:      issues,
        Tickets:     ticketsCreated,
        Timestamp:   time.Now(),
    })
    a.LastActivity = time.Now()

    result := fmt.Sprintf("%s\n\nCreated tickets: %v", analysis, ticketsCreated)
    return &result, nil
}
```

### GraphQL API generated automatically

```go
// Your Threads conversation becomes this API endpoint
func ReviewPullRequest(agentId string, prData string) (string, error) {
    result, err := agents.SendMessage(
        agentId,
        "analyze_pull_request",
        agents.WithData(prData),
    )
    if err != nil {
        return "", err
    }
    if result == nil {
        return "", fmt.Errorf("no response from agent")
    }
    return *result, nil
}
```

## What you get with ejected code

### Complete Modus app

Your exported agent runs on **Modus**, Hypermode's open source agent runtime:

```bash
# Your agent becomes a standard Modus app
git clone your-exported-agent
cd code-review-agent
modus dev      # Local development
modus deploy   # Production deployment
```

### Standard microservices and APIs

The exported code isn't a prototype—it's enterprise-grade software that becomes:

- **Standard microservices** deployable on your infrastructure
- **API endpoints** that integrate with existing systems
- **Version-controlled code** you can customize and extend
- **Audit-able logic** that developers can review and trust

Technical features include:

- **Persistent Memory**: Agent state survives restarts and failures
- **Concurrent Execution**: Handle thousands of simultaneous operations
- **Sand-boxed Security**: Each agent instance runs in isolation
- **Built-in Observability**: Logging, tracing, and debugging out of the box
- **WebAssembly Runtime**: Fast, portable execution anywhere—server, edge, or
  desktop

### Developer-friendly handoff

Platform teams get real software they can audit and extend:

- **Full Code Transparency**: Every behavior from Threads is visible in code
- **Standard DevOps**: CI/CD, testing, monitoring work normally
- **No Vendor Lock-in**: Runs anywhere Modus runs
- **Version Control**: Treat agents like any other microservice

## The power of Modus

Your ejected agent is built on Modus, an open source, serverless framework
designed specifically for agent development:

### Key features

- **WebAssembly powered runtime**: Small, portable, high-performance execution
  engine
- **Built-in agent memory**: Both short-term and long-term memory with graph
  data structures
- **Flexible tool support**: Consume Model Context Protocol (MCP) servers or
  build custom tools
- **Serverless scale-to-zero**: Agents spin up on demand and scale to zero when
  idle
- **Language-agnostic**: Write in Go, Rust, AssemblyScript, or your language of
  choice
- **Full observability**: Action-level tracing and inference logging for
  debugging

### When to eject to code

Common use cases for ejecting include:

- **Auditing agent logic** before putting it into production
- **Integrating agent code** into a larger system or microservices architecture
- **Modifying, extending, or customizing** generated code to meet advanced
  requirements
- **Ensuring reproducibility** and version tracking via GitHub or other source
  control tools
- **Custom integrations** beyond available Connections
- **Complex multi-agent coordination** with custom orchestration logic
- **Integration with existing systems** that require specific deployment
  patterns
- **Full development lifecycle control** including testing, staging, and
  production environments
- **Team ownership** where developers need to maintain and extend agent logic

## Learn more about Modus

Ready to dive deeper into agent development with Modus? The ejected code is just
the beginning.

**[Explore the complete Modus documentation →](/modus)**

Learn about:

- Building agents from scratch with the Modus framework
- Advanced memory management and persistence patterns
- Custom tool development and Model Context Protocol integration
- Multi-agent coordination and workflow orchestration
- Production deployment and scaling strategies

## Your agent works perfectly in Threads

For many use cases, keeping your agent hosted automatically in Threads is
ideal—the Hypermode platform handles deployment, scaling, and maintenance for
you.

**Ready for more control?** When you need to hand off to engineers, integrate
with existing systems, or build coordinated multi-agent workflows, ejecting to
code gives you a complete Modus app that your development team can own, extend,
and deploy anywhere.

---

_Your Threads conversation was just the design phase. With Modus, you can build
agents that become as reliable and scalable as any microservice in your
infrastructure._

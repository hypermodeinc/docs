---
title: "What is a Function?"
description: "Learn about your basic operatives in Modus"
"og:title": "What is a Function? - Modus"
---

## Functions in Modus

Functions in Modus are your reliable field operatives—specialized agents who
handle specific missions with precision and speed. Like elite reconnaissance
units, they get in, complete their objective, and report back. No unnecessary
complications, no lingering presence, just pure operational efficiency.

You can think of a function as an endpoint—each function you write automatically
becomes a callable API endpoint that external systems can access.

Functions are the backbone of your intelligence network, handling everything
from data gathering to AI-powered analysis, all while maintaining perfect
operational discipline.

## Operational profile

Functions are stateless, request-response operations designed for fast,
predictable missions. They're your go-to operatives when you need quick
intelligence gathering, data processing, or tactical strikes without maintaining
ongoing surveillance between operations.

### Core capabilities

- **Mission-focused**: Each operation is independent with no memory of previous
  assignments
- **Lightning fast**: Optimized for sub-second mission completion
- **Infinitely scalable**: Deploy as many operatives as needed
- **Clean operations**: Straightforward request-in, intel-out pattern
- **Auto-deployed**: Exposed automatically as GraphQL queries or mutations

## How functions become endpoints

When you deploy your operatives, Modus automatically exposes them through a
GraphQL API. Your functions become either **queries** (for gathering
intelligence) or **mutations** (for operational changes) based on their mission
type.

### Intelligence gathering queries

Most functions become GraphQL queries—perfect for reconnaissance and data
retrieval:

```go
// This function becomes a GraphQL query
func GatherThreatIntelligence(source string) (*ThreatReport, error) {
    // Intelligence gathering operation
    return fetchThreatData(source)
}

// This function becomes a GraphQL query
func AnalyzeSecurityPatterns() (*SecurityAssessment, error) {
    // Analysis operation using AI models
    return generateSecurityAnalysis()
}
```

Your operatives are now accessible via GraphQL:

```graphql
query {
  gatherThreatIntelligence(source: "network_logs") {
    threatLevel
    indicators
    recommendations
  }

  analyzeSecurityPatterns {
    riskScore
    anomalies
    actionItems
  }
}
```

**Response:**

```json
{
  "data": {
    "gatherThreatIntelligence": {
      "threatLevel": "HIGH",
      "indicators": ["unusual_traffic", "failed_auth_attempts"],
      "recommendations": ["immediate_investigation", "block_suspicious_ips"]
    },
    "analyzeSecurityPatterns": {
      "riskScore": 8.5,
      "anomalies": ["off_hours_access", "geographic_anomaly"],
      "actionItems": ["verify_user_identity", "enable_2fa"]
    }
  }
}
```

### Operational change mutations

Functions that modify data automatically become GraphQL mutations. Modus detects
these by their mission prefixes:

```go
// This becomes a GraphQL mutation
func CreateSecurityAlert(data AlertInput) (*SecurityAlert, error) {
    // Create new security alert
    return deploySecurityAlert(data)
}

// This becomes a GraphQL mutation
func UpdateThreatLevel(id string, level string) (*ThreatAssessment, error) {
    // Update threat assessment
    return modifyThreatRecord(id, level)
}
```

Now you can execute operational changes:

```graphql
mutation {
  createSecurityAlert(
    data: {
      type: "INTRUSION_ATTEMPT"
      severity: "CRITICAL"
      source: "firewall_logs"
    }
  ) {
    alertId
    status
    timestamp
  }

  updateThreatLevel(id: "threat_001", level: "CRITICAL") {
    id
    newLevel
    escalated
  }
}
```

**Response:**

```json
{
  "data": {
    "createSecurityAlert": {
      "alertId": "alert_20250115_001",
      "status": "ACTIVE",
      "timestamp": "2025-01-15T14:30:00Z"
    },
    "updateThreatLevel": {
      "id": "threat_001",
      "newLevel": "CRITICAL",
      "escalated": true
    }
  }
}
```

Functions starting with `create`, `update`, `delete`, and similar action words
automatically become mutations.

## Mission example: field conditions intelligence analysis

Here's a complete tactical operation that demonstrates how functions integrate
external APIs with AI models for intelligence analysis:

```go
package main

import (
    "fmt"
    "strings"
    "github.com/hypermodeinc/modus/sdk/go/pkg/http"
    "github.com/hypermodeinc/modus/sdk/go/pkg/models"
    "github.com/hypermodeinc/modus/sdk/go/pkg/models/openai"
)

type WeatherIntel struct {
    City        string  `json:"city"`
    Temperature float64 `json:"temperature"`
    Conditions  string  `json:"conditions"`
    Analysis    string  `json:"analysis"`
}

const modelName = "text-generator"

// Operative: Gather weather intelligence and provide tactical analysis
func GatherWeatherIntelligence(city string) (*WeatherIntel, error) {
    // Fetch weather data from OpenWeatherMap API
    url := fmt.Sprintf(
        "https://api.openweathermap.org/data/2.5/weather?q=%s&appid={{API_KEY}}&units=metric",
        city,
    )

    response, err := http.Fetch(url)
    if err != nil {
        return nil, err
    }
    if !response.Ok() {
        return nil, fmt.Errorf(
            "weather intelligence gathering failed: %d %s",
            response.Status,
            response.StatusText,
        )
    }

    // Parse weather data
    var weatherData struct {
        Name string `json:"name"`
        Main struct {
            Temp float64 `json:"temp"`
        } `json:"main"`
        Weather []struct {
            Description string `json:"description"`
        } `json:"weather"`
    }

    response.JSON(&weatherData)

    conditions := "unknown"
    if len(weatherData.Weather) > 0 {
        conditions = weatherData.Weather[0].Description
    }

    // Generate tactical analysis
    analysis, err := analyzeTacticalConditions(
        weatherData.Name,
        weatherData.Main.Temp,
        conditions,
    )
    if err != nil {
        fmt.Printf("Tactical analysis failed for %s: %v\n", weatherData.Name, err)
        analysis = "Analysis unavailable - proceed with standard protocols"
    }

    return &WeatherIntel{
        City:        weatherData.Name,
        Temperature: weatherData.Main.Temp,
        Conditions:  conditions,
        Analysis:    analysis,
    }, nil
}

// Analyze weather conditions for tactical implications
func analyzeTacticalConditions(city string, temp float64, conditions string) (string, error) {
    model, err := models.GetModel[openai.ChatModel](modelName)
    if err != nil {
        return "", err
    }

    prompt := `You are a tactical analyst evaluating weather conditions for field operations.
    Provide a brief tactical assessment of how these weather conditions might impact
    outdoor activities, visibility, and operational considerations in 1-2 sentences.`

    content := fmt.Sprintf(
        "Location: %s, Temperature: %.1f°C, Conditions: %s",
        city,
        temp,
        conditions,
    )

    input, err := model.CreateInput(
        openai.NewSystemMessage(prompt),
        openai.NewUserMessage(content),
    )
    if err != nil {
        return "", err
    }

    input.Temperature = 0.7

    output, err := model.Invoke(input)
    if err != nil {
        return "", err
    }

    return strings.TrimSpace(output.Choices[0].Message.Content), nil
}
```

This operative automatically becomes available as a GraphQL query:

```graphql
query {
  gatherWeatherIntelligence(city: "London") {
    city
    temperature
    conditions
    analysis
  }
}
```

You'll receive a tactical intelligence report like:

```json
{
  "data": {
    "gatherWeatherIntelligence": {
      "city": "London",
      "temperature": 12.3,
      "conditions": "light rain",
      "analysis": "
        Light rain conditions will reduce visibility for surveillance operations and may impact equipment performance.
        Recommend waterproof gear and consider delayed outdoor activities requiring clear sight lines."
    }
  }
}
```

### Deploying your operative

To use this function, you'll need to:

Sign up for a free API key at [OpenWeatherMap](https://openweathermap.org/api)

Add the connection to your `modus.json`:

```json
{
  "connections": {
    "weather-api": {
      "type": "http",
      "baseUrl": "https://api.openweathermap.org/",
      "queryParameters": {
        "appid": "{{API_KEY}}"
      }
    }
  }
}
```

Set your API key in `.env.dev.local`:

```sh
MODUS_WEATHER_API_API_KEY=your_openweathermap_api_key_here
```

## When to deploy agents

Functions are perfect for most tactical operations, but when you need persistent
surveillance, complex multi-phase operations, or operatives that remember every
detail of ongoing investigations, it's time to deploy your
[agents](/modus/agents).

Consider upgrading to agents when missions require:

- **Operational memory** across multiple engagements
- **Conversation intelligence** that builds over time
- **Multi-phase operations** spanning days or weeks
- **Recovery protocols** from mission failures
- **Continuous monitoring** with state preservation

Your functions form the tactical backbone of your intelligence operations—fast,
reliable, and always ready for the next mission. They handle the day-to-day
operations while your agents manage the long-term strategic initiatives.

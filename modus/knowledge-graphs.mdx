---
title: "What about knowledge graphs?"
description:
  "Build persistent intelligence networks using agents, functions, and knowledge
  graphs"
"og:title": "What about knowledge graphs? - Modus"
---

## Knowledge graphs in Modus

Your operatives need more than just memory—they need intelligence networks.
While agents maintain their own operational state and memory across missions,
knowledge graphs provide something fundamentally different: shared institutional
knowledge that captures relationships between entities, events, and intelligence
across your entire organization.

At Hypermode, we recognize that knowledge graphs aren't just storage—they're
becoming critical infrastructure for next-generation AI systems. That's why
we've invested deeply in Dgraph, bringing enterprise-grade graph capabilities to
Modus applications.

This is where knowledge graphs transform your Modus deployment from isolated
operatives into a coordinated intelligence network with shared institutional
memory.

## What are intelligence networks?

Intelligence networks in Modus combine:

- **Agent state**: personal operational memory that each agent maintains across
  missions
- **Knowledge graphs**: shared institutional intelligence that captures
  relationships between entities, events, and intelligence across your
  organization
- **Functions**: rapid tactical operations for data processing and analysis
- **AI models**: advanced pattern recognition and decision-making intelligence

Think of it as the difference between what an individual operative remembers
versus what your intelligence agency knows. Agent state is personal memory—what
happened to this specific operative, what conversations they've had, what tasks
they're tracking. Knowledge graphs are institutional intelligence—how threats
relate to each other, which indicators connect to which actors, what patterns
emerge across all operations.

## Setting up your intelligence infrastructure

First, connect to your knowledge graph by adding this to your `modus.json`:

```json
{
  "connections": {
    "dgraph": {
      "type": "dgraph",
      "connString": "dgraph://your-graph.hypermode.host:443?sslmode=verify-ca&bearertoken={{API_KEY}}"
    }
  },
  "models": {
    "text-generator": {
      "sourceModel": "meta-llama/Llama-3.2-3B-Instruct",
      "provider": "hugging-face",
      "connection": "hypermode"
    }
  }
}
```

Set your credentials in `.env.dev.local`:

```sh
MODUS_DGRAPH_API_KEY=your_graph_api_key_here
```

## Building an intelligence operation

Let's walk through a realistic intelligence scenario that demonstrates how all
these components work together. You're building a system to track anomalous
Agent behavior in the simulated reality. The operation needs to:

1. Rapidly import new Agent sightings and behavioral data
2. Find patterns across historical Agent encounters
3. Coordinate ongoing surveillance operations
4. Provide strategic analysis to the resistance

### Step 1: rapid intelligence import

When new Agent activity is detected in the Matrix, you need to process it
quickly. This is perfect for a stateless function:

```go
type AgentSighting struct {
    SightingID   string `json:"sighting_id"`
    AgentName    string `json:"agent_name"`
    Location     string `json:"location"`
    Behavior     string `json:"behavior"`
    ThreatLevel  int    `json:"threat_level"`
    Timestamp    string `json:"timestamp"`
}

func ImportAgentSighting(sighting AgentSighting) (*string, error) {
    // AI-powered analysis of the Agent behavior
    analysis, _ := analyzeAgentWithAI(sighting.Behavior)

    // Store in knowledge graph - builds institutional intelligence
    mutation := dgraph.NewMutation().WithSetJson(fmt.Sprintf(`{
        "dgraph.type": "AgentSighting",
        "sighting_id": "%s",
        "agent_name": "%s",
        "location": "%s",
        "behavior": "%s",
        "threat_level": %d,
        "timestamp": "%s",
        "ai_analysis": "%s"
    }`, sighting.SightingID, sighting.AgentName, sighting.Location,
        sighting.Behavior, sighting.ThreatLevel, sighting.Timestamp, analysis))

    dgraph.ExecuteMutations("dgraph", mutation)

    result := fmt.Sprintf("Agent sighting processed: %s", sighting.SightingID)
    return &result, nil
}

func analyzeAgentWithAI(behavior string) (string, error) {
    model, _ := models.GetModel[openai.ChatModel]("text-generator")

    prompt := `Analyze this Agent behavior pattern and assess threat level,
               behavioral changes, and tactical implications for resistance operations.`

    input, _ := model.CreateInput(
        openai.NewSystemMessage(prompt),
        openai.NewUserMessage(behavior),
    )
    input.Temperature = 0.3

    output, _ := model.Invoke(input)
    return strings.TrimSpace(output.Choices[0].Message.Content), nil
}
```

Now let's deploy this intelligence import function and test it. Since this
function creates data, it automatically becomes a GraphQL mutation:

```graphql
mutation {
  importAgentSighting(
    sighting: {
      sightingId: "SIGHT-2025-001"
      agentName: "Smith"
      location: "Downtown Loop - Financial District"
      behavior: "Unusual pattern recognition algorithm detected.
                Agent displaying enhanced replication capabilities
                beyond normal parameters."
      threatLevel: 9
      timestamp: "2025-01-15T14:30:00Z"
    }
  )
}
```

**Response:**

```json
{
  "data": {
    "importAgentSighting": "Agent sighting processed: SIGHT-2025-001"
  }
}
```

Behind the scenes, the AI model analyzed the Agent behavior and the knowledge
graph now contains both the raw sighting data and the AI-enhanced analysis,
ready to be connected to other related Agent encounters across the resistance
network.

### Step 2: strategic analysis using institutional knowledge

Now that we've got the Agent sighting data in our knowledge graph, let's analyze
the broader threat landscape. This function queries relationships across all
stored Agent data:

```go
type ThreatAnalysisResponse struct {
    SightingCount    int      `json:"sighting_count"`
    ActiveAgents     []string `json:"active_agents"`
    ThreatAssessment string   `json:"threat_assessment"`
    Recommendations  []string `json:"recommendations"`
}

func AnalyzeAgentPatterns(timeRange string) (*ThreatAnalysisResponse, error) {
    // Query institutional knowledge - traverses relationships
    query := dgraph.NewQuery(`
        query analyzeAgents($since: string) {
            sightings(func: ge(timestamp, $since)) {
                agent_name
                behavior
                threat_level
                ai_analysis
            }
        }
    `).WithVariable("$since", timeRange)

    response, _ := dgraph.ExecuteQuery("dgraph", query)

    // Parse and extract threat data
    var data SightingsData
    json.Unmarshal([]byte(response.Json), &data)

    // Generate strategic assessment using AI with graph context
    assessment, _ := generateThreatAssessment(data.Sightings)

    return &ThreatAnalysisResponse{
        SightingCount:    len(data.Sightings),
        ActiveAgents:     extractActiveAgents(data.Sightings),
        ThreatAssessment: assessment,
        Recommendations:  generateRecommendations(len(data.Sightings)),
    }, nil
}

func generateThreatAssessment(sightings interface{}) (string, error) {
    model, _ := models.GetModel[openai.ChatModel]("text-generator")

    prompt := `Based on these Agent sightings, provide a strategic threat
               assessment focusing on behavioral patterns and risks to
               resistance operations.`

    sightingsJson, _ := json.Marshal(sightings)
    input, _ := model.CreateInput(
        openai.NewSystemMessage(prompt),
        openai.NewUserMessage(fmt.Sprintf("Agent surveillance data: %s",
            string(sightingsJson))),
    )
    input.Temperature = 0.4

    output, _ := model.Invoke(input)
    return strings.TrimSpace(output.Choices[0].Message.Content), nil
}

// Helper functions for data extraction and recommendations
func extractActiveAgents(sightings []AgentSightingData) []string { /* ... */ }
func generateRecommendations(count int) []string { /* ... */ }
```

Let's query our surveillance intelligence data using this analysis function:

```graphql
query {
  analyzeAgentPatterns(timeRange: "2025-01-01T00:00:00Z") {
    sightingCount
    activeAgents
    threatAssessment
    recommendations
  }
}
```

**Response:**

```json
{
  "data": {
    "analyzeAgentPatterns": {
      "sightingCount": 3,
      "activeAgents": ["Smith", "Brown", "Jones"],
      "threatAssessment": "Critical escalation detected. Agent Smith
                          showing unprecedented adaptive behavior patterns
                          consistent with version upgrades. Behavioral
                          analysis indicates coordinated search algorithms
                          across multiple Agent instances.",
      "recommendations": [
        "Emergency extraction protocols",
        "Activate deep cover cells",
        "Increase surveillance sweeps"
      ]
    }
  }
}
```

Notice how the AI model provided strategic analysis by examining patterns across
all related Agent encounters in the knowledge graph—something no single sighting
could reveal.

### Step 3: deploying persistent surveillance agents

For ongoing operations, deploy an agent that maintains continuous surveillance
of the simulated reality. Unlike functions, agents remember their operational
state:

```go
type SurveillanceAgent struct {
    agents.AgentBase

    // Persistent agent state (personal operational memory)
    MonitoredSectors   []string             `json:"monitored_sectors"`
    AlertThresholds    map[string]int       `json:"alert_thresholds"`
    LastSweepTime      time.Time            `json:"last_sweep_time"`
    OperationalStatus  string               `json:"operational_status"`
    SightingsTracked   int                  `json:"sightings_tracked"`
}

func (s *SurveillanceAgent) Name() string {
    return "SurveillanceAgent"
}

func (s *SurveillanceAgent) OnInitialize() error {
    s.MonitoredSectors = []string{
        "Downtown Loop", "Megacity Financial", "Industrial District"}
    s.AlertThresholds = map[string]int{"Smith": 5, "Brown": 7, "Jones": 7}
    s.OperationalStatus = "Active"
    s.SightingsTracked = 0
    s.LastSweepTime = time.Now()
    return nil
}

func (s *SurveillanceAgent) OnReceiveMessage(
    msgName string, data *string) (*string, error) {
    switch msgName {
    case "continuous_surveillance":
        return s.runContinuousSurveillance()
    case "get_status":
        return s.getOperationalStatus()
    default:
        return nil, fmt.Errorf("unrecognized directive: %s", msgName)
    }
}

func (s *SurveillanceAgent) runContinuousSurveillance() (*string, error) {
    // Query knowledge graph for new sightings since last sweep
    query := dgraph.NewQuery(`
        query getRecentSightings($since: string) {
            sightings(func: ge(timestamp, $since)) {
                agent_name
                threat_level
                location
            }
        }
    `).WithVariable("$since", s.LastSweepTime.Format(time.RFC3339))

    dgraph.ExecuteQuery("dgraph", query)

    // Update agent's personal operational state
    s.LastSweepTime = time.Now()
    s.SightingsTracked += 1 // Simplified counting

    result := fmt.Sprintf(`Surveillance sweep completed at %s.
                           Monitoring %d sectors.
                           Matrix integrity: COMPROMISED`,
        s.LastSweepTime.Format("15:04:05"),
        len(s.MonitoredSectors))
    return &result, nil
}

func (s *SurveillanceAgent) getOperationalStatus() (*string, error) {
    status := fmt.Sprintf(`Surveillance Agent Status:
- Operational: %s
- Monitoring %d sectors: %s
- Last sweep: %s
- Tracking %d ongoing sightings
- Alert thresholds: Smith=%d, Brown=%d, Jones=%d`,
        s.OperationalStatus,
        len(s.MonitoredSectors),
        strings.Join(s.MonitoredSectors, ", "),
        s.LastSweepTime.Format("2006-01-02 15:04:05"),
        s.SightingsTracked,
        s.AlertThresholds["Smith"],
        s.AlertThresholds["Brown"],
        s.AlertThresholds["Jones"])
    return &status, nil
}
```

To make these agent capabilities accessible via GraphQL, we need wrapper
functions that handle deployment and messaging:

```go
// Register your agent type during initialization
func init() {
    agents.Register(&SurveillanceAgent{})
}

// Deploy a new surveillance agent - this becomes a GraphQL mutation
func DeploySurveillanceAgent() (string, error) {
    agentInfo, _ := agents.Start("SurveillanceAgent")
    return agentInfo.Id, nil
}

// Initiate continuous surveillance - this becomes a GraphQL mutation
func InitiateSurveillance(agentId string) (string, error) {
    result, _ := agents.SendMessage(agentId, "continuous_surveillance")
    return *result, nil
}

// Get surveillance status - this becomes a GraphQL query
func GetSurveillanceStatus(agentId string) (string, error) {
    result, _ := agents.SendMessage(agentId, "get_status")
    return *result, nil
}
```

Deploy your surveillance agent to monitor the Matrix:

```graphql
mutation {
  deploySurveillanceAgent
}
```

**Response:**

```json
{
  "data": {
    "deploySurveillanceAgent": "agent_neo_001"
  }
}
```

Your agent is now running with its own dedicated execution environment, ready to
maintain long-term surveillance operations against the machine intelligence.

### Step 4: coordinated surveillance operations

Now initiate continuous monitoring. The agent queries the knowledge graph for
new Agent activity and maintains its own operational state:

```graphql
mutation {
  initiateSurveillance(agentId: "agent_neo_001")
}
```

**Response:**

```json
{
  "data": {
    "initiateSurveillance": "Surveillance sweep completed at 14:35:22.
                           Monitoring 3 sectors.
                           Matrix integrity: COMPROMISED"
  }
}
```

The agent is now continuously monitoring the knowledge graph, tracking Agent
patterns, and maintaining its own operational memory about the digital
battleground.

### Step 5: building comprehensive intelligence

Let's add more Agent sightings to see the intelligence network grow. You can run
this operation multiple times with different data:

```graphql
mutation {
  importAgentSighting(
    sighting: {
      sightingId: "SIGHT-2025-002"
      agentName: "Brown"
      location: "Megacity Financial - Server Room B12"
      behavior: "Agent Brown detected implementing advanced
                countermeasures against known resistance
                encryption protocols. Adaptive learning
                subroutines active."
      threatLevel: 8
      timestamp: "2025-01-15T15:45:00Z"
    }
  )
}
```

**Response:**

```json
{
  "data": {
    "importAgentSighting": "Agent sighting processed: SIGHT-2025-002"
  }
}
```

Continue building your intelligence database with activities like:

- **Matrix infiltration detected**: Agent Jones coordinating with Smith on power
  grid systems
- **Encryption breakthrough**: Agent Brown has cracked resistance communication
  protocols
- **Replication surge**: Agent Smith creating multiple instances across
  financial networks

### Step 6: comprehensive surveillance report

After building your intelligence network with multiple sightings and operations,
check your complete surveillance status:

```graphql
query {
  getSurveillanceStatus(agentId: "agent_neo_001")
}
```

**Response:**

```json
{
  "data": {
    "getSurveillanceStatus": "Surveillance Agent Status:
                            - Operational: Active
                            - Monitoring 3 sectors: Downtown Loop,
                              Megacity Financial, Industrial District
                            - Last sweep: 2025-01-15 16:45:22
                            - Tracking 12 ongoing sightings
                            - Recent activities: Matrix infiltration,
                              encryption breakthrough, replication surge,
                              pattern adaptation, network synchronization
                            - Alert thresholds: Smith=5 (EXCEEDED),
                              Brown=7 (EXCEEDED), Jones=7 (ACTIVE)
                            - Threat status: CRITICAL - IMMEDIATE EXTRACTION ADVISED"
  }
}
```

## The intelligence advantage

What you've just built demonstrates the power of combining all four Modus
components in the fight against the machines:

**Functions** rapidly processed incoming Agent sightings and provided strategic
analysis by querying institutional surveillance data

**Knowledge graphs** stored not just the raw sighting data, but the
relationships between Agent encounters, behavioral patterns, and threat
escalations that enabled sophisticated anomaly detection

**AI models** enhanced both the initial behavioral analysis and the strategic
assessment by understanding context across all related surveillance intelligence

**Agents** maintained continuous surveillance operations, building personal
operational memory while leveraging shared institutional knowledge about Agent
activities throughout the resistance network

## Key insights from this operation

**Agent memory vs institutional knowledge**: the surveillance agent maintained
its own operational state (which sectors it's monitoring, when it last swept,
what sightings it's tracking) while accessing shared institutional surveillance
data in the knowledge graph

**Relationship intelligence**: the knowledge graph revealed behavioral patterns
across multiple Agent encounters that no single sighting could show

**Coordinated operations**: functions handled rapid tactical sighting processing
while the agent managed strategic, long-term surveillance of the simulated
reality

**AI-enhanced analysis**: models provided pattern recognition across both
personal agent memory and institutional surveillance knowledge

At Hypermode, we've built this integration because we believe knowledge graphs
are becoming critical infrastructure for next-generation AI systems. Our
investment in Dgraph ensures enterprise-grade graph capabilities that scale with
your resistance operations.

## What you've accomplished

You now have a complete surveillance network that can:

- **Import** Agent sighting data rapidly through functions with AI behavioral
  analysis
- **Detect** complex threat relationships through graph queries and pattern
  recognition
- **Monitor** continuously through persistent surveillance agents
- **Coordinate** responses across multiple resistance operatives
- **Learn** and adapt through AI-enhanced behavioral analysis
- **Survive** system failures with persistent state and relationships

This isn't just a database with some AI on top—it's a coordinated intelligence
network where agents, functions, models, and knowledge graphs work together to
provide capabilities that none could achieve alone. Welcome to the real world.

## Next steps

Ready to deploy your surveillance network against the machines? Check out:

- [Dgraph integration guide](/modus/modus-dgraph) for advanced graph operations
- [Agent coordination patterns](/modus/agents) for multi-agent workflows
- [Production deployment](/modus/deploying) for scaling your intelligence
  network

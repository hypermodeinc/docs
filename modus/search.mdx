---
title: Search
description: "Adding search function to your app"
---

The Modus Collections API enables developers to store, retrieve, and search data within collections using both natural language and vector-based search methods.

## Prerequisites

Before implementing search, ensure you have [defined a collection in the manifest](../app-manifest#collections) and have a working Hypermode setup.

### Understanding Key Components

- **Collections**: A **collection** is a structured storage that organizes and stores textual data and associated metadata, such as vectors or labels.
  Collections enable sophisticated search, retrieval, and classification tasks using embeddings and vectors.

In this example, `myProducts` is the collection used to store product descriptions.

- **Search Methods**: <TO DO>

# Configure your search method

The search functionality relies on vector embeddings. In order to be used for vector-based search and comparison, each item in the collection must be converted into a vector representation.

### Export an embedding function

TO DO explain signature and refer to models change example to use minilm

<CodeGroup>

```ts AssemblyScript
export function embed(text: string[]): f32[][] {
  const model = models.getModel<OpenAIEmbeddingsModel>("embeddings");
  const input = model.createInput(text);
  const output = model.invoke(input);
  return output.data.map<f32[]>((d) => d.embedding);
}
```

```ts Go
package main

import (
	"github.com/hypermodeAI/functions-go/pkg/models"
	"github.com/hypermodeAI/functions-go/pkg/models/experimental"
)

func Embed(text []string) ([][]float32, error) {
model, err := models.GetModel[experimental.EmbeddingsModel]("minilm")
if err != nil {
return nil, err
}

    input, err := model.CreateInput(text...)
    if err != nil {
    	return nil, err
    }
    output, err := model.Invoke(input)
    if err != nil {
    	return nil, err
    }
    return output.Predictions, nil

}

```

</CodeGroup>

TO DO: explain how to export from index.ts if exported from embed.ts

### declare the search method

TO DO: reference to manifest

## Add Items to the Collection

First, we need to populate the collection with items (e.g., product descriptions). You can insert individual or multiple items using the `upsert` and `upsertBatch` methods, respectively.

Use `collections.upsert` to insert a product description into the collection. If you don't specify a key, a unique key will be generated for you.

<CodeGroup>
```ts AssemblyScript
export function addProduct(description: string): string {
  const response = collections.upsert(
    "myProducts",  // Collection name defined in the manifest
    null,          // using null to let Modus generate a unique ID
    description    // the text to store
    );
  return response.keys[0]; // return the identifier of the item
}
````

```ts Go
func AddProduct(description string) ([]string, error) {
	res, err := collections.Upsert(
        "myProducts",  // Collection name defined in the manifest
        nil,           // using nil to let Modus generate a unique ID
        description,   // the text to store
        nil            // we don't have labels for this item
        )
	if err != nil {
		return nil, err
	}
	return res.Keys, nil
}
```

</CodeGroup>

To add a batch of product descriptions, use the `collections.upsertBatch` method.

## Implement Natural Language Search

With the products stored, you can now search the collection using natural language. The `collections.search` function computes an embedding for the search query and compares it with the embeddings of the items in the collection.

TO DO : change the example to use only one searchMethod

```ts
export function searchProducts(
  product: string,
  maxItems: i32,
): collections.CollectionSearchResult[] {
  const responseArr: collections.CollectionSearchResult[] = [];
  const searchMethods = ["searchMethod1", "searchMethod2"]; // defined search methods

  for (let i = 0; i < searchMethods.length; i++) {
    const response = collections.search(
      "myProducts",
      searchMethods[i],
      product,
      maxItems,
      true,
    );
    responseArr.push(response);
  }

  return responseArr;
}
```

Hereâ€™s how it works:

- **Input**: A string (`product`) that describes the product you are searching for.
- **Search Method**: The code iterates through each search method in `searchMethods` to perform the search.
- `maxItems`: The maximum number of items you want to retrieve.
- **Result**: The results are returned in the form of an array of `CollectionSearchResult` objects, each corresponding to a search method.

### Search Result Format

Each search returns an array of `CollectionSearchResult`, containing the following fields:

- `collection`: The name of the collection.
- `status`: The status of the operation (e.g., success, error).
- `objects`: The search result items with their text, distance, and score values.

```json
{
  "collection": "myProducts",
  "status": "success",
  "objects": [
    {
      "key": "item-key-123",
      "text": "Sample product description",
      "distance": 0.05,
      "score": 0.95
    }
  ]
}
```

TO DO: explain distance and score range (-1 1 or 0 1 ?)

## Search by Vector

If you want to search using a vector (instead of text), you can retrieve the vector associated with an item by its key, then perform a search using that vector.

```ts
export function searchProductsById(
  productId: string,
  maxItems: i32,
): collections.CollectionSearchResult[] {
  const responseArr: collections.CollectionSearchResult[] = [];
  const searchMethods = ["searchMethod1", "searchMethod2"];

  for (let i = 0; i < searchMethods.length; i++) {
    const vec = collections.getVector(
      "myProducts",
      searchMethods[i],
      productId,
    );
    const response = collections.searchByVector(
      "myProducts",
      searchMethods[i],
      vec,
      maxItems,
      true,
    );
    responseArr.push(response);
  }

  return responseArr;
}
```

This method is useful when you have an item's ID and want to find similar items in the collection by comparing vectors.

## Recomputing Search Indexes

Sometimes, you may need to recompute the embeddings for all items in the collection for a specific search method. This can be useful if you change the underlying embedding model.

```ts
export function recomputeIndexes(): Map<string, string> {
  const responseArr: Map<string, string> = new Map<string, string>();
  const searchMethods = ["searchMethod1", "searchMethod2"];

  for (let i = 0; i < searchMethods.length; i++) {
    const response = collections.recomputeSearchMethod(
      "myProducts",
      searchMethods[i],
    );
    if (!response.isSuccessful) {
      responseArr.set(searchMethods[i], response.error);
    }
    responseArr.set(searchMethods[i], response.status);
  }

  return responseArr;
}
```

## Conclusion

This guide explains how to implement natural language-based or vector similarity searches in your application. By following these steps, you can build a robust search API for any collection of text data, such as product descriptions, using the power of vector embeddings and search methods.
TO DO: conclusion, use cases and next steps (simialrity clustering ...) multiple search method, image embedding etc ...

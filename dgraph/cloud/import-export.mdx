---
title: Importing and Exporting data from Dgraph Cloud
---

## Exporting and importing data in Dgraph Cloud

You can export your data as an Administrator from one Dgraph Cloud backend, and
then import this data back into another Dgraph instance or Dgraph Cloud backend.
You can also export data from Dgraph Cloud using the Dgraph Cloud API. For more
information, see [Cloud API documentation](./api/backup).

To import data to Dgraph Cloud, see [Live Loader](/dgraph/admin/live-loader).

As an `Administrator` you can export data from a Dgraph Cloud shared instance or
dedicated instance. On a dedicated instance with multi-tenancy feature enabled
you can export data across the cluster, or a specific namespace depending on the
type of administrative privileges you have.

### Exporting data from Dgraph Cloud using the console

1. In the `Admin` section of the Dgraph Cloud console, go to `Settings`.
2. In the `Exports` tab, click `Create Export`.
3. In the `New export` dialog, select the format you want to export.
4. Click `Create`.

Depending on the format that you chose to create an export, three files are
generated.

<Note>
  Ensure that you download these files as soon as possible because the links to
  download these files expire after 48 hours from the time they were generated.
</Note>

### Exporting data from Dgraph Cloud using a GraphQL client

1. Generate API Key for authentication.
1. Make a note of the GraphQL endpoint for the instance from `Overview` in the
   Dgraph Cloud console. Replace `/graphql` with `/admin/slash`in the GraphQL
   endpoint to get the `<ADMIN_ENDPOINT>`.
1. Authenticate the `admin` API requests by adding the `<APIKEY>` as the
   `Dg-Auth` header to every HTTP request.
1. To export data you need to send authenticated request to `<ADMIN_ENDPOINT>`.
1. Export data in JSON or RDF `<FORMAT>` using this mutation:

   ```graphql
   mutation {
     export(format: "<FORMAT>") {
       response {
         message
         code
       }
       exportId
       taskId
     }
   }
   ```

   A response similar to this appears:

   ```{
       "data": {
          "export":"exports/2011-12-08/0x18986fd-558223708",
          "response": {
             "code": "Success",
             "message": "Export queued with ID 0x9d2e13e8a"
          },
          "taskID": "0x9d2e13e8a"
       }
      }
   }
   ```

1. Make a note of the `<EXPORT_ID>` and the `<TASK_ID>`.

1. To get the status of export and the signed URLs to download the exported
   files, use this mutation:

   ```graphql
   query {
     exportStatus(exportId: "<EXPORT_ID>", taskId: "<TASK_ID>") {
       kind
       lastUpdated
       signedUrls
       status
     }
   }
   ```

   Depending on the format that you chose to create an export, three files are
   generated.

<Note> Ensure that you download these files as soon as possible
because the signed URLs to download these files expire after 48 hours from the
time they were generated. You can use `curl -O <SIGNED_URL>` to download the
files to the current directory. </Note>

### Exporting data from Dgraph Cloud programmatically

You can also export data from Dgraph Cloud programmatically using the Dgraph
Cloud API. For more information, see
[Cloud API documentation](https://dgraph.io/docs/cloud/cloud-api/backup/#export-data).

### Exporting data with multi-tenancy feature enabled in Dgraph Cloud

<Note>
  With Multi-Tenancy feature enabled, for any GraphQL request you need to
  provide the `accessJWT` for the specific user in the `X-Dgraph-AccessToken`
  header.
</Note>

You can trigger two types of exports:

- Cluster-wide export: this is an export of the entire backend (including all
  namespaces). This request can be only triggered by the
  [_Guardian of Galaxy_](https://dgraph.io/docs/enterprise-features/multitenancy/#guardians-of-the-galaxy)
  users.
- Namespace-specific export: this is an export of a specific namespace. This
  request can be triggered by the _Guardian of Galaxy_ users and by the
  _Guardian of Namespace_ users.

### Cluster-wide exports

This can only be done by the **Guardian of Galaxy** users (super admin), the
steps are:

1. Get the `accessJWT` token for the _Guardian of Galaxy_ user. Send the
   following GraphQL mutation to the `/admin` endpoint:

   ```graphql
   mutation login($userId: String, $password: String, $namespace: Int) {
     login(userId: $userId, password: $password, namespace: $namespace) {
       response {
         accessJWT
         refreshJWT
       }
     }
   }
   ```

   Your variables should be referring to the _Guardian of Galaxy_ user:

   ```json
   {
     "userId": "groot",
     "password": "password",
     "namespace": 0
   }
   ```

2. Once obtained the `accessJWT` token you need to pass it in
   `X-Dgraph-AccessToken` Header and only then you can send the following
   GraphQL mutation to `/admin/slash` endpoint:

   ```graphql
   mutation {
     export(namespace: -1) {
       response {
         code
         message
       }
       exportId
       taskId
     }
   }
   ```

3. Once done, you can now send the following GraqhQL mutation to get the
   `signedUrls` from where you can download your export files:

   ```graphql
   query {
     exportStatus(
       exportId: "<paste-your-exportId>"
       taskId: "<paste-your-taskId>"
     ) {
       kind
       lastUpdated
       signedUrls
       status
     }
   }
   ```

### Namespace-specific exports

Namespace-specific exports can be triggered by the _Guardian of Galaxy_ users.
In this case you can follow the same steps for the Cluster-wide exports and
replace the namespace value from `-1` to the namespace you want to export. It is
important that you get the `accessJWT` token for the _Guardian of Galaxy_ user
and pass it in the `X-Dgraph-AccessToken` header.

For example, if you want to export the namespace `0x123` your GraphQL request
sent to the `/admin/slash` endpoint would look like:

```graphql
mutation {
  export(namespace: 123) {
    response {
      code
      message
    }
    exportId
    taskId
  }
}
```

You can also trigger namespace-specific export using the _Guardian of Namespace_
users, in this case there is no need to specify any namespace in the GraphQL
request as these users can only export their own namespace. It is important that
you get the `accessJWT` token for the _Guardian of Namespace_ user and pass it
in the `X-Dgraph-AccessToken` header.

The GraphQL request sent to the `/admin/slash` endpoint would be:

```graphql
mutation {
  export {
    response {
      code
      message
    }
    exportId
    taskId
  }
}
```
